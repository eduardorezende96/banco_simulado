# banco_simulado
Simulador de um banco
Autor:Eduardo Domingues Malta de Rezende

# Como rodar
Para rodar o programa, primeiramente é necessário instalar o django. Após isso, algumas extensões também são necessárias, como o django crispy forms, que pode ser instalado através de pip install 'pip install django-crispy-forms'. Além disso, também são necessárias as intalações das bibliotecas xhtml2pdf, que pode ser instalado através de 'pip install xhtml2pdf', e beatiful soup, instalável através de 'pip install BeautifulSoup 4'. Isso realizado, primeiramente é necessário realizar as migrações dos bancos de dado. Para isso, basta entrar na pasta principal e rodar 'python manage.py makemigrations', e em seguida 'python manage.py migrate'. Com isso realizado, basta rodar o servidor, através do comando 'python manage.py runserver'. Com isso, basta copiar o link indicado no terminal, e abri-lo em um browser, que a aplicação estará disponível.


# O que consegui fazer e como funciona
## Parte 1 - Tela inicial
Dentre os requisitos passado, consegui realizar primeiramente o cadastro e o login. Para isso, usei as funcionalidades do django, que facilita o registro e login de usuário de forma mais segura, evitando ataques CSRF, SQL injection, e outros, facilitando o desenvolvimento e a manutenção, tornando o software mais seguro e facilitando sua manutenção. Além disso, também foi usado um banco de dados relacional, uma biblioteca em linguagem C que implementa um banco de dados relacional. O SQLite3 é uma biblioteca cuja implementação é realizada com auxílio do próprio django, sendo necessário, nesse caso, apenas o nome, email, senha e confirmação de senha, para que o usuário seja registrado. Ao entrar na página inicial, antes de se fazer o login, apenas duas opções estarão disponíveis, justamente de cadastro e login, e mais nenhuma outra. Após o usuário se cadastrar e fazer o cadastro, porém, o usuário observará apenas uma mensagem de boas vindas, usuário, além de um botão de logout, na tela de login. Além disso, existe também uma barra lateral (side bar), em que o usuário pode ver o que pode ser feito. Para o usuário que não está logado ainda, apenas o botão home estará disponível. Porém, após o login, será possível visualisar na barra mais algumas opções. 


## Parte 2 - Explicando o banco de dados
  Antes de explicar sobre as funções, é necessário entender o banco de dados por completo. Foi criado duas classes de dados, sendo a primeira delas a lista de movimentações (de saques ou depósitos), que possui uma chave estrangeira para o usuário. 

## Lista de Movimentações (MovesList)
  Essa classe foi criada com a finalidade de facilitar que o usuário se organize de forma que ache melhor, dividindo seus saques e depósitos da forma que deseje. Ela possui apenas dois atributos, além de sua chave estrangeira. O primeiro é o nome da lista, criado pelo próprio usuário, e o segundo é o saldo total, que inicia sempre como 0 (zero), e é atualizado a cada movimentação realizada nessa lista. Essa classe possui relação de 1 (um) para muitos para com os usuários, ou seja, cada lista deve possuir exatamente um usuário (de acordo com quem está logado no momento da criação da mesma), mas em contrapartida um usuário pode possuir quantas listas deseje. Dito isso, é necessário ao menos uma lista para realizar saque ou depósito. 
Para finalizar, isso vai ser explicado melhor posteriormente, mas é importante falar que a lista vai ter seu saldo total (totalLista) atualizado apenas nas movimentações realizadas naquela lista.


## Movimentação (Move)
  Essa classe se refere a realização dos saques e depósitos realizados. Ela possui quatro atributos, além de uma chave estrangeira que a relaciona a classe de lista de movimentações, explicada no parágrafo anterior. O primeiro desses atributos é o de valor (value), que seria o valor desejado da operação do usuário (saque ou depósito). Se o usuário deseja sacar ou depositar R$400.00, por exemplo, o valor 400 seria salvo nesse campo. Os 2 (dois) atributos seguintes são relacionados ao momento em que a movimentação foi realizada. São os atributos data e hora, sendo criados duas funções, que detectam exatamente esses dados na hora em que a movimentação é confirmada. Dessa forma, se um saque ocorre no dia 12/12/2022, às 10:34:34, esses valores serão salvos nos respectivos campos. Para finalizar, existe o atributo tipo, que se refere justamente ao tipo de operação realizada (saque ou depósito). 
  Importante destacar também, que enquanto o atributo valor é do tipo floatfield, e data e hora são do tipo charfield, o atributo tipo é do tipo booleanfield, sendo positivo quando um depósito é realizado, e negativo quando um saque é realizado. Para finalizar, essa lista possui relação de um (ou zero) para muitos com a lista de movimentações. Dessa forma, uma lista de movimentações possui zero ou mais movimentações, enquanto cada movimentação possui apenas uma lista.


## Parte 3 - Ver Saldo
  A primeira dessas opções é a de ver saldo. Como dito anteriormente, o saldo de cada lista é inicializado como zero e atualizado individualmente a cada movimentação realizada naquela lista específica. Dessa forma, para verificar o saldo total, basta percorrer todas as listas criadas por um usuário, verificando o saldo de cada uma, e ir incrementando o valor de cada lista em uma variável. Após isso, essa variável é impressa na tela. Esse variável, chamada de saldo (calcular, no código, transformada em um dict chamado saldo, para que possa ser renderizado em um html e visualizado pelo usuário.


## Parte 4 - Criar Lista
  A segunda opção é a de criar lista. Para o usuário, basta digitar o nome da lista na caixa de texto e apertar no botão 'Criar Lista', e uma lista será criada atrelada ao usuário (ou seja, apenas esse usuário poderia ter acesso a essa lista). Para que isso seja realizado, foi criado um formulário. Esse formulário importa uma classe chamada CreateNewList, que será utilizada para validar a entrada, impedindo que sejam criadas listas com nomes vazios, por exemplo, garantindo, de certa forma, que o nome foi inserido corretamente. Caso esse formulário (form) seja válido, uma nova variável receberá o valor convertido para um formato aceitável pela classe da lista.
Essa classe então será salva automaticamente, pelo código, e adicionada ao banco de dados relacional.


## Parte 5 - Sacar ou depositar
  Na terceira opção, relacionada a classe de movimentação (Move), o usuário deve primeiramente selecionar em qual lista essa operação deverá ser realizada. Lista selecionada, basta digitar um número não negativo, e escolher entre sacar ou depositar. O usuário deve então apertar em um dos dois botões disponíveis à direita do input. Cada botão possui uma cor e um texto que explica o que cada botão realiza de forma simples. Dessa forma, o primeiro botão é azul, e é responsável pela operação "depósito", enquanto o segundo botão é vermelho e é responsável pelo saque.
  Após o usuário digitar um valor válido, o objeto será criado, e associado à lista, de acordo com a opção selecionada (sacar ou depositar). Primeiramente será identificado em qual lista esse objeto está relacionado, para que a chave estrangeira seja obtida, e esse objeto seja criado da forma correta. Dependendo da opção, as coisas vão ser processadas de maneira diferentes, mas há similaridades. Primeiramente, será identificado se o valor digitado pode ser convertido para float, ou seja, se o que foi inserido pelo usuário realmente é um número válido, e não um nome, ou algo do tipo. Além disso, será verificado se esse valor é maior ou igual a zero, evitando situações em que o usuário digita um valor negativo por engano, ou para se beneficiar de alguma forma. Além disso, o valor do saldo da lista (totalLista) também é atualizado, mas há uma validação extra, caso o usuário tenha escolhido sacar.
  A primeira diferença é justamente no atributo tipo. O atributo tipo será atribuído como falso (False) se a opção selecionada for a de 'sacar', enquanto será atribuído como True, caso for a de 'depositar'. Além disso, a opção sacar possui uma validação extra. Enquanto, o usuário poderia depositar qualquer valor, ele não deveria poder sacar um valor maior do que o seu saldo. Dessa forma, o saldo é calculado, da mesma forma como descrito na parte 3, e a operação seria ser invalidada caso o valor inserido seja maior que o seu saldo.
  Caso a operação seja validada, duas coisas serão realizadas. A primeira delas é realizar a criação do objeto e salvar no banco de dados. A segunda se refere a atualização do saldo daquela lista, de acordo com o valor inserido e o tipo do movimento, subtração caso for saque e adição caso for depósito. Importante destacar que enquanto o saldo total do usuário não pode ser negativo, o de uma lista especifica pode ser. O valor utilizado para validação é o total.
  
  
## Parte 6 - Baixar extrato
  Por último, existe a opção de baixar o extrato. Primeiramente, ao clicar, será exibido o extrato, exibindo, primeiramente o nome de usuário e a data e a hora em que o extrato foi gerado. Em seguida, será impresso uma tabela, com todos os atributos dos objetos relacionados a movimentações (Move) criados pelo usuário, de todas as listas. Essa tabela é organizada primeiramente de acordo com a a ordem de criação das listas, e em seguida pela ordem pela qual essas movimentações foram realizadas. Dessa forma, movimentações realizadas em listas de movimentação que foram criadas antes, vão ser exibidas antes, e vice-versa. Já entre as movimentações realizadas dentro de uma mesma lista serão impressas de acordo com a ordem em que esses movimentos foram salvos.
  Também existe um botão para realizar o download dessa página como pdf. Porém, por questões de tempo, não consegui fazer com que as informações do usuário sejam impressas da forma correta. Consegui gerar um pdf, com todos os respectivos campos, mas, apesar de passar bastante tempo nisso, não foi possível transformar essa página em um html completo, com todas as informações referentes. Peço, porém, que isso seja considerado, mesmo que parcialmente, visto que o usuário consegue visualisar essas informações, apenas não consegue baixar o arquivo.
  
  
# Considerações finais
## Parte 1 - Bibliotecas utilizadas
  Esse trabalho foi desenvolvido em python, utilizando principalmente o django, para criar os modelos, o sistema de cadastro e login de usuário, e a aplicação em si. Foi utilizado html e CSS para a exibição dos dados para o usuário, e para sua interação com o sistema. Foi utilizado bootstrap para facilitar o desenvolvimento dos templates, tornando a aparência da aplicação mais agradável para o usuário. Crispy forms foi utilizado na criação dos formulários, tornando-os mais elegantes e simples. As bilbiotecas xhtml2pdf, beautiful soup, os, sys, e url lib foram utilizadas na tentativa de converter a página html em um arquivo.

## Parte 2 - Organização dos arquivos
  A aplicação está dentro da pasta principal "mysyte", criada através do comando "python manage.py startproject", do django. Foram criado 2 pastas através disso, uma nomeada de main, que contém a aplicação em si, como os modelos, templates, formulários, etc. Dentro dessa pasta principal, foi criado um novo projeto django ("python manage.py startproject" register), sendo responsável pelo registro e cadastro dos usuários dp banco simulado.
